{
  "language": "Solidity",
  "sources": {
    "contracts/FractionalAssetManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ncontract AssetBloc {\n    // DATA\n    address private immutable i_owner;\n    uint private counter;\n    uint private timeInDays;\n    uint private rentDueTime;\n\n    struct Shares {\n        address walletAddress;\n        uint assetId;\n        string propertyName;\n        uint shareValueInPercentage;\n        uint shareValueInBSC;\n        uint locked;\n        uint lockedTime;\n    }\n    struct OwnersOfAsset {\n        uint id;\n        address owner;\n        uint percentageValue;\n    }\n\n    struct User {\n        address walletAddress;\n        uint balanceBSC;\n    }\n\n    struct Asset {\n        uint id;\n        string propertyName;\n        string propertyAbout;\n        uint propertyValue;\n        uint sharesAvailable;\n        uint sharesSold;\n        Status status;\n        uint rentValuePerYear;\n        uint startTime;\n        uint endTime;\n        address rentee;\n        bool paid;\n    }\n\n    enum Status {\n        NotAvailable,\n        Inuse,\n        Available\n    }\n\n    // Mappings\n    mapping(address => uint) private users;\n    mapping(uint => Asset) private assets;\n    mapping(address => Shares[]) private shares;\n    mapping(uint => OwnersOfAsset[]) private assetOwners;\n\n    // Arrays\n\n    event InvestorAdded(address indexed wallet, uint balance);\n    event AssetAdded(\n        uint indexed id,\n        string propertyname,\n        string propertyabout,\n        uint propertyvalue,\n        uint sharesavailable,\n        uint sharessold,\n        Status status,\n        uint valueperyear,\n        address rentee,\n        bool paid\n    );\n    event AssetEdited(\n        uint indexed id,\n        string propertyname,\n        string propertyabout,\n        uint propertyvalue,\n        Status status,\n        uint rentValuePerYear\n    );\n    event CustomerAdded(address indexed wallet);\n    event BoughtShares(\n        address indexed wallet,\n        uint indexed id,\n        string propertyname,\n        uint amount,\n        uint sharesinpercentage\n    );\n    event SellShares(\n        address indexed wallet,\n        uint indexed id,\n        uint amount,\n        uint sharespercentage\n    );\n    event LockedShares(\n        address indexed wallet,\n        uint id,\n        uint timeInDays,\n        uint amount,\n        uint sharesPercent\n    );\n    event UnlockedShares(address indexed wallet, uint id);\n    event RentDepositShare(\n        address indexed wallet,\n        uint amount,\n        uint indexed id,\n        Status status,\n        bool paid,\n        uint timeRented\n    );\n    event RentDue(uint indexed id, uint rentDueTime, bool paid);\n    event KickedOut(uint indexed id, Status status);\n    event Deposit(address indexed walletAddress, uint amount);\n    event BalanceWithdrawn(address indexed walletAddress, uint amount);\n\n    constructor() {\n        i_owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == i_owner, \"Not Owner\");\n        _;\n    }\n    modifier onlyUser() {\n        require(users[msg.sender] > 0, \"User does not exist\");\n        _;\n    }\n\n    modifier isShareholder(uint id) {\n        OwnersOfAsset[] storage owners = assetOwners[id];\n        bool foundOwner = false;\n        for (uint i; i < owners.length; i++) {\n            if (owners[i].owner == msg.sender) foundOwner = true;\n        }\n        require(foundOwner == true, \"Not an asset owner!\");\n\n        _;\n    }\n\n    // Add Asset\n    function addAsset(\n        string calldata propertyname,\n        string calldata propertyabout,\n        uint propertyvalue,\n        Status status,\n        uint rentValuePerYear\n    ) external onlyOwner {\n        counter++;\n        propertyvalue = propertyvalue * (10 ** 18);\n        rentValuePerYear = rentValuePerYear * (10 ** 18);\n        assets[counter] = Asset(\n            counter,\n            propertyname,\n            propertyabout,\n            propertyvalue,\n            100,\n            0,\n            status,\n            rentValuePerYear,\n            0,\n            0,\n            msg.sender,\n            false\n        );\n\n        emit AssetAdded(\n            counter,\n            propertyname,\n            propertyabout,\n            propertyvalue,\n            100,\n            0,\n            status,\n            rentValuePerYear,\n            msg.sender,\n            false\n        );\n    }\n\n    function editAsset(\n        uint id,\n        string calldata propertyname,\n        string calldata propertyabout,\n        uint propertyvalue,\n        Status status,\n        uint rentValuePerYear\n    ) external onlyOwner {\n        require(assets[id].id != 0, \"Asset with the Id does not exist\");\n        Asset storage asset = assets[id];\n\n        asset.propertyName = propertyname;\n        asset.propertyAbout = propertyabout;\n        assets[id].rentValuePerYear = rentValuePerYear * (10 ** 18);\n        assets[id].propertyValue = propertyvalue * (10 ** 18);\n        assets[id].status = status;\n\n        emit AssetEdited(\n            counter,\n            propertyname,\n            propertyabout,\n            propertyvalue,\n            status,\n            rentValuePerYear\n        );\n    }\n\n    // Buy shares\n    function buyShares(uint id, uint _amount) external onlyUser {\n        _amount = _amount * (10 ** 18);\n        Asset storage assetShares = assets[id];\n        uint propValue = assetShares.propertyValue;\n        uint sharesCalculatedInPercentage = calcShares(propValue, _amount);\n        require(\n            sharesCalculatedInPercentage <= assetShares.sharesAvailable,\n            \"Shares amount not available\"\n        );\n        uint balance = users[msg.sender];\n        require(balance >= _amount, \"Insufficient funds\");\n\n        unchecked {\n            users[msg.sender] -= _amount;\n        }\n        Shares[] storage userShare = shares[msg.sender];\n        OwnersOfAsset[] storage owner = assetOwners[id];\n\n        assetShares.sharesAvailable -= sharesCalculatedInPercentage;\n        assetShares.sharesSold += sharesCalculatedInPercentage;\n\n        bool verify = false;\n        for (uint i = 0; i < userShare.length; i++) {\n            if (userShare[i].assetId == id) {\n                userShare[i]\n                    .shareValueInPercentage += sharesCalculatedInPercentage;\n                userShare[i].shareValueInBSC += _amount;\n                verify = true;\n                break;\n            }\n        }\n        bool check = false;\n        for (uint i = 0; i < owner.length; i++) {\n            if (owner[i].owner == msg.sender) {\n                owner[i].percentageValue += sharesCalculatedInPercentage;\n                check = true;\n                break;\n            }\n        }\n        if (!verify) {\n            shares[msg.sender].push(\n                Shares(\n                    msg.sender,\n                    id,\n                    assets[id].propertyName,\n                    sharesCalculatedInPercentage,\n                    _amount,\n                    0,\n                    0\n                )\n            );\n        }\n        if (!check) {\n            owner.push(\n                OwnersOfAsset(id, msg.sender, sharesCalculatedInPercentage)\n            );\n        }\n\n        emit BoughtShares(\n            msg.sender,\n            id,\n            assets[id].propertyName,\n            _amount,\n            sharesCalculatedInPercentage\n        );\n    }\n\n    // Sell shares\n    function sellShares(uint id, uint amount) external isShareholder(id) {\n        amount = amount * (10 ** 18);\n        Shares[] storage userShares = shares[msg.sender];\n        uint totalSharesOfUser;\n        bool sharesBought = false;\n        uint i;\n        for (i = 0; i < userShares.length; i++) {\n            if (userShares[i].assetId == id) {\n                totalSharesOfUser = userShares[i].shareValueInBSC;\n                sharesBought = true;\n                break;\n            }\n        }\n        require(\n            sharesBought && totalSharesOfUser > amount,\n            \"Didn't buy shares\"\n        );\n\n        uint propValue = assets[id].propertyValue;\n        uint sharesPercent = calcShares(propValue, amount);\n        OwnersOfAsset[] storage owner = assetOwners[id];\n        for (uint x = 0; x < owner.length; x++) {\n            if (owner[x].owner == msg.sender) {\n                owner[x].percentageValue -= sharesPercent;\n                break;\n            }\n        }\n        userShares[i].shareValueInBSC -= amount;\n        userShares[i].shareValueInPercentage -= sharesPercent;\n        users[msg.sender] += amount;\n\n        emit SellShares(msg.sender, id, amount, sharesPercent);\n    }\n\n    // Lock bought shares\n    function lockShares(\n        uint id,\n        uint amount,\n        uint time\n    ) external isShareholder(id) {\n        amount = amount * (10 ** 18);\n\n        Shares[] storage userShares = shares[msg.sender];\n        uint propValue = assets[id].propertyValue;\n        uint sharesPercent = calcShares(propValue, amount);\n        for (uint i = 0; i < userShares.length; i++) {\n            if (userShares[i].assetId == id) {\n                userShares[i].locked += amount;\n                userShares[i].lockedTime += time;\n                break;\n            }\n        }\n\n        emit LockedShares(msg.sender, id, timeInDays, amount, sharesPercent);\n    }\n\n    // Unlock bought shares\n    function unlockShares(uint id) external isShareholder(id) {\n        uint currentTime = block.timestamp;\n        Shares[] storage userShares = shares[msg.sender];\n\n        for (uint i = 0; i < userShares.length; i++) {\n            if (userShares[i].assetId == id) {\n                require(\n                    currentTime >= userShares[i].lockedTime,\n                    \"Lock time hasn't elasped\"\n                );\n                userShares[i].locked = 0;\n                userShares[i].lockedTime = 0;\n                break;\n            }\n        }\n\n        emit UnlockedShares(msg.sender, id);\n    }\n\n    // Rent Asset and Share profit among the shareholders\n    function rentShare(uint id) external payable {\n        Asset storage assetToRent = assets[id];\n        uint rent = assetToRent.rentValuePerYear;\n        require(msg.value == rent, \"Insufficient funds\");\n        require(\n            assetToRent.status == Status.Available,\n            \"Asset is not available\"\n        );\n\n        OwnersOfAsset[] storage owners = assetOwners[id];\n        for (uint i = 0; i < owners.length; i++) {\n            address wallet = owners[i].owner;\n            uint sharesInPercent = owners[i].percentageValue;\n            uint sharesInBSC = calcPercentBSC(rent, sharesInPercent);\n            users[wallet] += sharesInBSC;\n        }\n        assetToRent.paid = true;\n        assetToRent.startTime = block.timestamp;\n        assetToRent.endTime = assetToRent.startTime + 365 days;\n        assetToRent.rentee = msg.sender;\n        assetToRent.status = Status.Inuse;\n\n        emit RentDepositShare(\n            msg.sender,\n            msg.value,\n            id,\n            Status.Inuse,\n            assetToRent.paid,\n            assetToRent.startTime\n        );\n    }\n\n    function rentDue(uint id) external isShareholder(id) {\n        Asset storage assetToRent = assets[id];\n        require(assetToRent.status == Status.Inuse, \"No owner!\");\n\n        require(block.timestamp > assetToRent.endTime, \"Time still valid\");\n        assetToRent.paid = false;\n\n        // emit RentDue(id, assetToRent.paid);\n    }\n\n    // Email the company who is the onlyOwner to kickout the occupant as the person has not paid\n    function kickOut(uint id) external onlyOwner {\n        Asset storage assetToRent = assets[id];\n        require(assetToRent.status == Status.Inuse, \"No owner!\");\n        require(assetToRent.paid == false, \"Customer rent still valid\");\n        assetToRent.status = Status.Available;\n\n        emit KickedOut(id, Status.Available);\n    }\n\n    function withdraw(uint amount) external onlyUser {\n        amount = amount * (10 ** 18);\n        uint balance = users[msg.sender];\n        require(balance >= amount, \"Insufficient funds\");\n\n        unchecked {\n            users[msg.sender] -= amount * (10 ** 18);\n        }\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n\n        emit BalanceWithdrawn(msg.sender, amount);\n    }\n\n    // // Deposit\n    function deposit() external payable {\n        unchecked {\n            users[msg.sender] += msg.value;\n        }\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function calcShares(uint propVal, uint amount) private pure returns (uint) {\n        uint x = 100 * amount;\n        return x / propVal;\n    }\n\n    function calcPercentBSC(\n        uint profit,\n        uint sharesInPercent\n    ) private pure returns (uint) {\n        uint x = profit * sharesInPercent;\n        return x / 100;\n    }\n\n    // Query Functions\n\n    function getOwner() external view returns (address) {\n        return i_owner;\n    }\n\n    function getAssets(uint id) external view returns (Asset memory) {\n        return assets[id];\n    }\n\n    function getCurrentCount() external view returns (uint) {\n        return counter;\n    }\n\n    function getContractBalance() external view onlyOwner returns (uint) {\n        return address(this).balance;\n    }\n\n    function getUserBalance() external view returns (uint) {\n        return users[msg.sender];\n    }\n\n    function getAssetByStatus(\n        Status _status\n    ) external view returns (Asset[] memory) {\n        Asset[] memory assetWithStatus;\n        uint count = 0;\n        for (uint i = 1; i <= counter; i++) {\n            if (assets[i].status == _status) {\n                assetWithStatus[count] = assets[i];\n                count++;\n            }\n        }\n\n        return assetWithStatus;\n    }\n\n    function getAssetById(uint id) external view returns (Asset memory) {\n        return assets[id];\n    }\n\n    function getSharesAvailable(uint id) external view returns (uint) {\n        return assets[id].sharesAvailable;\n    }\n\n    function getSharesSold(uint id) external view returns (uint) {\n        return assets[id].sharesSold;\n    }\n\n    function getUserShares() external view returns (Shares[] memory) {\n        return shares[msg.sender];\n    }\n\n    function getAssetOwners(\n        uint id\n    ) external view returns (OwnersOfAsset[] memory) {\n        return assetOwners[id];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}